# Detailed Report — How bottom-plane delivered power is computed (with attenuation in lossy medium 2)

## Scope
This report focuses on the part of the simulation that estimates:
1. power transmitted through each meniscus triangle,
2. power that actually reaches the bottom/postprocess plane,
3. how attenuation in lossy medium 2 is included.

Main implementation area:
- `EMinterface/tile_overlap.cpp`

Supporting functions used by that section:
- `EMinterface/include/em/tile_wrapper.hpp`
- `EMinterface/em_solver.cpp`
- `EMinterface/include/geom/triangle.hpp`
- `EMinterface/include/em/postprocess_grid.hpp`

---

## 1) Where this happens in the execution flow

Inside `tile_overlap.cpp`, the bottom-plane delivered power is computed in the triangle loop:

```cpp
for (const auto& tri_idx : mesh.tris) {
    ...
    em::TileSolveResult res = em::solve_on_triangle(tri, media, beam, true);
    ...
    const double Pin = max(0, dot(res.S_avg, n_int)) * A_face;
    ...
    // project footprint to z1=Cpp
    ...
    // attenuation from Im(k)
    double att = exp(-2.0 * dot(alpha, disp));
    const double P_on_plane = Pin * att;
    const double I = P_on_plane / A_fp;
    grid.add_triangle_uniform(tri2d, I);
}
```

So this is a **per-triangle energy transport model**: each interface facet contributes a local energy packet that is attenuated and then deposited on the target plane.

---

## 2) Step-by-step: from local EM solution to delivered power

## Step A — Solve local interface physics on one triangle

`tile_overlap.cpp` calls:

- `em::solve_on_triangle(tri, media, beam, true)` in `tile_wrapper.hpp`.

`solve_on_triangle` returns, among other values:
- `res.S_avg`: local transmitted time-average Poynting vector in global coordinates (`W/m^2`),
- `res.d_poynting`: unit direction of energy flow,
- `res.kp2_global`: complex transmitted wave vector in medium 2.

These outputs are generated by:
- `EMInterfaceSolver` (TE/TM boundary solve, Snell-vector construction, lossy media support) in `em_solver.cpp`,
- `poynting_avg_real(...)` in `tile_wrapper.hpp`.

### Physical meaning
For each facet, the code computes how much energy crosses the interface and in which direction that energy propagates in medium 2.

---

## Step B — Compute power crossing the interface facet

In `tile_overlap.cpp`:

1. interface normal (oriented with incidence):
   - `n_int = tri_normal_pointing_with_incident(tri, s_in)`
2. face area:
   - `A_face = geom::area(tri)`
3. power entering medium 2 through that facet:

\[
P_{in} \approx \max\big(0,\,\mathbf S_{avg}\cdot\hat n_{int}\big)\,A_{face}
\]

implemented as:

```cpp
const double Pin = std::max(0.0, geom::dot(res.S_avg, n_int)) * A_face;
```

### Why this is correct in this model
- \(\mathbf S\cdot\hat n\) is normal power flux density through the facet.
- Multiplying by facet area gives power in watts.
- `max(0,...)` prevents non-physical negative delivery (backward crossing).

If `Pin <= 0`, the triangle does not contribute to bottom-plane delivery.

---

## Step C — Determine where that triangle power lands on the target plane

Target plane is `z1 = Cpp`.

The code uses energy-flow direction `dir = res.d_poynting` and projects each triangle vertex onto that plane:

\[
t = \frac{Cpp - p_z}{dir_z}, \quad p' = p + t\,dir
\]

implemented by lambda `proj_to_plane`.

This creates a 2D footprint triangle `tri2d` on `(x1,y1)`.

Footprint area (`A_fp`) is computed by shoelace formula.

If `A_fp` is tiny or projection invalid, contribution is skipped.

### Why this step exists
The transmitted power through the interface is not delivered at the same `(x,y)`; refraction and local geometry move the energy footprint. This step maps interface power to the actual deposition location.

---

## Step D — Attenuation model in lossy medium 2 (core requested point)

This is the key part for lossy medium propagation.

### D.1 Build propagation displacement used for attenuation

The code uses facet centroid `c_face` and its projected point on `z1=Cpp`:

- `c_face = (v0+v1+v2)/3`
- `pc = proj_to_plane(c_face)`
- `disp = pc.second - c_face`

So `disp` is the path vector from interface facet to target plane, along `d_poynting` geometry used by the mapping.

### D.2 Extract attenuation vector from complex wave vector

From `res.kp2_global`:

```cpp
geom::Vec3 alpha = {
   -std::imag(res.kp2_global.x),
   -std::imag(res.kp2_global.y),
   -std::imag(res.kp2_global.z)
};
```

So:
\[
\boldsymbol\alpha = -\Im(\mathbf k_{p2})
\]

This matches the solver convention where physical branch ensures decay in propagation direction (see branch choice on `Im(k_{p2z})` in `em_solver.cpp`).

### D.3 Apply exponential decay

Attenuation factor:

\[
att = \exp\big(-2\,\boldsymbol\alpha\cdot\Delta\mathbf r\big)
\]

implemented as:

```cpp
double att = std::exp(-2.0 * geom::dot(alpha, disp));
att = std::clamp(att, 0.0, 1.0);
```

Then delivered power is:

\[
P_{on\_plane} = P_{in}\cdot att
\]

### Why factor 2?
In harmonic EM waves, field amplitude decays as \(e^{-\alpha s}\), while intensity/power scales with squared field magnitude, hence \(e^{-2\alpha s}\).

### Why dot product `alpha·disp`?
`alpha` is vectorial attenuation from complex `k`; `disp` is vector path. Dot product gives directional effective attenuation over that path.

### Role of clamping
`clamp(att,0,1)` makes postprocessing robust against numerical issues (e.g., tiny negative dot due to floating-point noise causing >1).

---

## Step E — Convert delivered power to irradiance and accumulate on grid

After attenuation:

\[
I = \frac{P_{on\_plane}}{A_{fp}}
\]

This `I` is treated as uniform on the footprint triangle and added to grid cells inside `tri2d` via:

- `grid.add_triangle_uniform(tri2d, I)` in `postprocess_grid.hpp`.

So final map is the sum of all triangle contributions.

---

## 3) Exact formulas used by the code (compact summary)

For each valid interface triangle `j`:

1. Interface crossing power
\[
P_{in,j}=\max(0,\mathbf S_j\cdot\hat n_j)A_j
\]

2. Path/attenuation
\[
\boldsymbol\alpha_j=-\Im(\mathbf k_{p2,j}),\qquad
att_j=\exp\big(-2\,\boldsymbol\alpha_j\cdot\Delta\mathbf r_j\big)
\]

3. Delivered power on target plane
\[
P_{plane,j}=P_{in,j}\,att_j
\]

4. Footprint irradiance (uniform per facet footprint)
\[
I_j=\frac{P_{plane,j}}{A_{fp,j}}
\]

5. Raster accumulation
\[
I_{grid}(x,y)=\sum_{j\,:\,(x,y)\in footprint_j} I_j
\]

---

## 4) How this links to `P_total_in` and `P_total_on_plane`

`tile_overlap.cpp` tracks two diagnostics:

- `P_total_in += Pin`
- `P_total_on_plane += P_on_plane`

Interpretation:
- `P_total_in`: total transmitted power entering medium 2 through all used facets.
- `P_total_on_plane`: attenuated power that reaches plane `z1=Cpp` under this model.

So the global attenuation effect is directly visible as:

\[
P_{total\_on\_plane} \le P_{total\_in}
\]

(except tiny numerical artifacts).

---

## 5) Important modeling assumptions in this specific implementation

1. **Facet-wise uniform deposition** on each projected footprint (no intra-facet gradient).
2. **Centroid path for attenuation** (single representative path per facet).
3. **Energy transport direction uses `d_poynting`**, not necessarily phase direction.
4. **No coherent interference accumulation** between facets at field level; map is power-sum.

These assumptions make the model efficient and stable for engineering estimation while keeping the essential lossy-medium attenuation physics.

---

## 6) Bottom line answer to your question

The power delivered at the bottom plane is computed in `tile_overlap.cpp` as:

1. transmitted facet power from local Poynting flux (`Pin`),
2. geometric transport to target plane along `d_poynting` (footprint + path),
3. exponential attenuation using `-Im(kp2_global)` and centroid displacement,
4. conversion to irradiance (`P_on_plane / A_fp`) and grid accumulation.

So attenuation in lossy medium 2 is explicitly included through:

\[
\boxed{\;att = \exp\big(-2(-\Im\mathbf k_{p2})\cdot\Delta\mathbf r\big)\;}
\]

applied per triangle before depositing power on the bottom-plane map.
