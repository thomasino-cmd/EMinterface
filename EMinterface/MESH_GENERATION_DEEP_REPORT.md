# Deep Technical Report — Mesh generation, geometry, storage, and equations

## Scope (exclusive focus)
This report covers only the mesh-related part of the project:
- which mesh is generated,
- how it is mathematically defined,
- how it is discretized,
- how it is stored in memory,
- how it is mapped to the meniscus surface,
- what equations govern shape and intersections,
- and how mesh quality/validity is enforced.

Primary implementation files:
- `EMinterface/include/em/beam_mesh.hpp`
- `EMinterface/include/em/meniscus_model.hpp`
- `EMinterface/include/em/meniscus_projection.hpp`
- `EMinterface/include/em/frames.hpp`
- `EMinterface/tile_overlap.cpp`
- `EMinterface/include/geom/triangle.hpp`

---

## 1) What mesh is being created

The code uses a **two-stage mesh concept**:

1. **Stage A (parametric beam mesh in x3-plane):**
   - A 2D triangular mesh on a disk in coordinates \((x_3,y_3,z_3=0)\).
   - This is generated by `generate_disk_mesh(...)`.

2. **Stage B (physical interface mesh on meniscus):**
   - Each 2D node is projected onto the curved meniscus.
   - Connectivity (triangles) is preserved from Stage A.
   - Result is a piecewise-planar 3D triangular mesh approximating the curved interface.

So the “real” meniscus mesh is obtained by **projected nodes + inherited triangulation**.

---

## 2) Meniscus shape equation (continuous surface model)

The continuous air–saline interface is defined in `ParaboloidMeniscus` as:

\[
z_1 = f_2(x_1,y_1)=k(x_1^2+y_1^2)+a_{pm}
\]

with parameters:

\[
a_{pm}=\frac{V}{\pi R_{in}^2}-\frac{D_m}{2},
\qquad
k=\frac{D_m}{R_{in}^2}
\]

where:
- \(V\): solution volume,
- \(R_{in}\): inner cuvette radius,
- \(D_m\): meniscus depth/curvature control.

This gives an axisymmetric paraboloid clipped by cuvette radius condition:

\[
x_1^2+y_1^2\le R_{in}^2
\]

(enforced by `inside_cuvette(...)`).

---

## 3) Stage A mesh generation in `beam_mesh.hpp`

## 3.1 Data structures (storage format)

`Mesh2D` is:

```cpp
struct Mesh2D {
    std::vector<geom::Vec2> nodes;
    std::vector<std::array<int,3>> tris;
};
```

Meaning:
- `nodes[i] = (x,y)` in 2D.
- `tris[t] = {i0,i1,i2}` references node indices.

This is a classic indexed triangular mesh format: compact and cache-friendly.

---

## 3.2 Polar disk discretization algorithm

Function:

```cpp
Mesh2D generate_disk_mesh(double Rf, int n_pr, int n_rays)
```

Parameters:
- `Rf`: beam disk radius.
- `n_pr`: points along each radius (including center and border).
- `n_rays`: number of angular sectors.

### Input constraints
- `Rf > 0`
- `n_pr >= 2`
- `n_rays >= 3`

### Node creation

1. Add center node:
\[
(0,0)
\]

2. For radial rings `ir = 1..n_pr-1`:
\[
r_{ir}=\frac{ir}{n_{pr}-1}R_f
\]

3. For each angle index `k = 0..n_rays-1`:
\[
a_k = 2\pi\frac{k}{n_{rays}}
\]

4. Add node:
\[
(x,y)=(r_{ir}\cos a_k,\;r_{ir}\sin a_k)
\]

So radial spacing is uniform, angular spacing is uniform.

---

## 3.3 Index mapping helper

Internal helper:

```cpp
idx(ir,k)
```

- `ir=0` returns center index `0`.
- for `ir>=1`: index is offset by ring and angular position.

This makes triangulation deterministic and avoids storing 2D ring arrays.

---

## 3.4 Triangle connectivity creation

### Center fan
For first ring:
- triangles: `{center, ring1[k], ring1[k+1]}` for all `k`.

### Between consecutive rings
For each ring pair `(ir, ir+1)` and angular sector `k`:
- define quad corners `a,b,c,d`.
- split quad into 2 triangles:
  - `{a,c,d}`
  - `{a,d,b}`

This gives full disk triangulation with periodic angular wrap.

---

## 4) Mesh resolution and element count formulas

Given `n_pr`, `n_rays`:

### Node count
- one center,
- plus `(n_pr-1)*n_rays` ring nodes,

\[
N_{nodes}=1+(n_{pr}-1)n_{rays}
\]

### Triangle count
- center fan: `n_rays`,
- each annular band (`n_pr-2` bands): `2*n_rays` triangles,

\[
N_{tri}=n_{rays}+2(n_{pr}-2)n_{rays}=n_{rays}(2n_{pr}-3)
\]

In `tile_overlap.cpp`, `n_rays = 6*(n_pr-1)`, so triangles scale roughly quadratically with `n_pr`.

---

## 5) From Stage A mesh to physical meniscus mesh (projection)

`tile_overlap.cpp` does:
1. generate 2D disk mesh (`mesh`).
2. allocate
   - `nodes_on_meniscus` (3D node array same size as `mesh.nodes`),
   - `ok` validity mask.
3. for each 2D node `(x3,y3)`, call:
   - `project_node_to_meniscus(fr, men, x3, y3)`.
4. if projection succeeds, store 3D point `p1` and mark valid.

Triangles are then rebuilt by reading index triplets in `mesh.tris` and pulling corresponding 3D points.

So connectivity is unchanged; only vertex coordinates change from 2D plane to 3D curved interface.

---

## 6) Projection math (equation solving that builds the real mesh)

This is the core geometry equation in `meniscus_projection.hpp`.

## 6.1 Parametric projection ray

Each node starts from `(x3,y3,0)` and is projected along `+z3` using parameter `t`.

Using frame parameters (`x_af, theta, phi, z0`), the code writes:

\[
x_1(t)=x_{1,0}+x_{1,1}t,
\qquad
y_1(t)=y_{1,0}+y_{1,1}t,
\qquad
z_1(t)=z_{1,0}+z_{1,1}t
\]

where coefficients are explicit functions of `x3,y3,theta,phi,x_af,z0`.

## 6.2 Intersection with meniscus

Impose surface equation:

\[
z_1(t)=k(x_1(t)^2+y_1(t)^2)+a_{pm}
\]

This becomes quadratic:

\[
A t^2 + B t + C = 0
\]

with:
- `A = k*c2`
- `B = k*c1 - z1_1`
- `C = k*c0 + apm - z1_0`

The solver picks the smallest nonnegative root (`smallest_nonneg_root`).

## 6.3 Validity checks

After root selection:
- compute candidate point `p1`.
- verify inside cuvette disk: `x1^2+y1^2 <= Rin^2`.
- only then mark `ok=true`.

This ensures the mesh on meniscus is physically inside the container aperture.

---

## 7) Coordinate-frame role in mesh creation (`frames.hpp`)

Mesh projection uses a tilted/shifted coordinate system via `Frames`:
- translations by `x_af` and `z0`,
- rotations `Rz(phi)` and `Ry(theta)`.

Why this matters for mesh:
- the same disk mesh in x3 can represent different beam alignments,
- projected mesh points move on meniscus accordingly,
- thus mesh geometry automatically includes beam misalignment and tilt effects.

So frame transforms are part of mesh placement, not only optics.

---

## 8) Final triangle geometry properties in 3D

After projection, each mesh cell becomes a 3D triangle:

```cpp
geom::Triangle tri{v0,v1,v2}
```

Geometric quantities then used downstream are from `triangle.hpp`:
- normal: `normal_unit(tri)`,
- area: `area(tri)`,
- centroid: `centroid(tri)`.

These are all derived from vector operations on projected vertices.

Thus, all local optical computations inherit directly from mesh geometry quality.

---

## 9) What exactly is stored at each stage

## Stage A (2D disk mesh)
- `mesh.nodes : Vec2[]`
- `mesh.tris : int[3][]`

## Stage B (projected meniscus mesh)
- `nodes_on_meniscus : Vec3[]` (same indexing as `mesh.nodes`)
- `ok : char[]` valid/invalid projection flags
- implicit 3D connectivity still `mesh.tris`

During loop, each triangle is instantiated on the fly from indices:
- if any node invalid, triangle skipped.

This design avoids storing a second full triangle list and keeps memory simple.

---

## 10) Mesh quality / numerical considerations

1. **Resolution controls**
   - `n_pr`, `n_rays` tune triangle size and curvature approximation.

2. **Near-center elements**
   - fan triangles around center can have different aspect ratio than outer bands.

3. **Projection failures**
   - if quadratic has no nonnegative root or point outside cuvette, node is invalid.
   - triangles touching invalid nodes are excluded.

4. **Curvature approximation**
   - continuous paraboloid is approximated piecewise-planar;
   - higher resolution reduces geometric discretization error.

5. **Angular periodicity**
   - index wrapping `(k % n_rays)` keeps mesh closed at 2π seam.

---

## 11) End-to-end mesh pipeline summary

\[
\text{Parameters }(R_f,n_{pr},n_{rays})
\rightarrow
\text{2D polar disk nodes+tris}
\rightarrow
\text{projection ray per node}
\rightarrow
\text{quadratic meniscus intersection}
\rightarrow
\text{valid 3D node set on paraboloid}
\rightarrow
\text{3D triangles via inherited connectivity}
\]

This is the full mesh creation workflow used by the simulation.

---

## 12) Practical interpretation

If you change only mesh parameters:
- `n_pr`, `n_rays` change discretization density.

If you change meniscus parameters:
- `V`, `Dm`, `Rin` change the continuous surface equation where nodes land.

If you change frame/alignment:
- `x_af`, `theta`, `phi` change where the same parametric disk intersects that surface.

So mesh geometry in this code is the result of **discretization + projection + coordinate transforms**.
